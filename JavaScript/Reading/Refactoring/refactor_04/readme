重构的目的在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。

重构：对软件内部结构的一种调整，目的是在 不改变软件可观察行为 的前提下，提高其可理解性，降低修改成本

重构思想：通过大量微小的行为步骤，完成最终的重构。小步骤彼此之间能够很好的组合

可观察行为：经过重构之后的代码所做的事与重构之前大致一致，用户行为完全一直

重构行为：1. 添加新功能 2. 重构
  添加新功能时不修改既有代码，重构是不添加新功能

重构目的：1. 改进软件设计：消除重复但功能相同的代码 2. 使软件更容易理解（理解程序的对象有两个：运行的计算机和阅读代码的人）3. 帮助寻找bug 4. 提高开发效率

何时重构：预备性重构（添加新功能之前，帮助理解代码，优化既有逻辑）；code review 

何时不应该重构：代码糟糕但是被封装起来，如果不需要去理解是不必要重构的；重写可能比重构更简单

测试：每一个项目都应该准备对应的测试代码，在每次重构之后进行一次测试，既可以减少bug的引入，又可以当出现bug的时候快速定位

框架的重构：好的架构设计是保证整个架构的灵活性。结合使用重构和YAGNI两种设计模式，重构是YAGNI的基础，而YAGNI又可以让重构更加易于展开。

重构的方向：
  1. 修改神秘的命名：函数声明、变量名、字段名等
  2. 重复代码：
    如果在多处出现相同的重复代码，使用`提炼函数`提炼重复的代码；
    如果重复的代码只是相似不是完全相同，先尝试`移动语句`重组代码顺序，再把相似的部分提炼；
    如果重复的部分位于用一个超类的不同的子类中，可以使用`函数上移`避免两个子类相互调用
  3. 过长函数：使用小函数代替过长函数。
    每当我们觉得需要通过注释来说明什么的时候，我们需要把说明的东西写进一个独立的函数中，并以其用途来命名。重要的是函数在‘做什么’和‘如何做’之间语义。
    大部分的函数都可以通过`提炼函数`找到合适集中在一起的部分，提炼称一个新的函数。如果一个函数中存在大量的参数和临时变量，将会对函数的提炼造成阻碍。
    + 可以使用`查询取代临时变量`来消除临时元素，`引入参数对象`和`保持对象完整`替代过长的参数列表。如果仍然不能够改变过多的临时变量和参数，那么可以是用`以命令取代函数`
    + 提炼代码一个好的思维方式是：1. 寻找注释 2. 条件表达式和循环（`分解条件表达式`）
    + 对于庞大的switch语句，可以尝试每一个case语句都提炼一个独立的函数。如果多个switch语句基于同一个条件进行分支选择，就应该使用`以多态取代条件表达式`
    循环
    + 对于循环语句，应该将循环和循环内容提炼为一个独立的函数。如果发现提炼的函数很难命名，说明这个函数在做多件事情，这个时候可以尝试使用`拆分循环`将其拆分成各自独立的函数
  4. 过长的函数列表
    + 如果可以通过向某个函数发起查询而获取另一个参数的值，那么就可以使用`以查询取代参数`去掉另外一个函数。
    + 如果可以从现有的数据结构中抽取多个数据，可以使用`保持对象完整`
    + 如果多个参数总是出现，那么可以使用`引入参数对象`将其合并成一个对象
    + 如果某个参数被作为区分函数行为的标记，可以使用`移除标记参数`
    + 如果多个函数使用同一个参数，可与使用`函数组合成类`，将这些参数变成类的共同字段
  5. 全局数据
    `封装变量` 用一个函数将全局变量包裹起来，这样在修改这些变量的时候我们就能看见修改的地方，再进一步将这个函数迁移到一个类或者一个模块当中，只允许模块内的代码使用它，从而控制作用域
  6. 可变的数据
    + `封装变量` 保证所有的数据的更新操作都通过少数的几个函数来执行
    + 如果一个变量在不同的时候被用于多个用途，那么`拆分变量` 将各自不同用途的变量进行拆分
    + 使用`移动语句`和`提炼函数`尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码和执行更新操作的代码分开
    + 设计api的时候将`查询函数和修改函数分离`确保调用者不会调用到有副作用的代码
    + `移除设置函数`
    + 如果可变数据在可控范围之外的地方计算出来，可以使用`查询取代派生变量`
    + `函数组合成类`或者`函数组合成变换`代替作用域变量
    + 如果一个变量在其内部结构中包含了数据，通常不要直接修改，而是`将引用对象改为只对象`
  7. 发散式变化
    + 当某一个模块在不同的上下文，需要修改的类似的内容，那么需要将每个内容对应的逻辑部分，拆分到各自的模块。避免在修改一个上下文的同时又要兼顾其他情况。保证上下文的一致性
    + 如果发生变化的两部分存在先后顺序，就可以`拆分阶段`将两个阶段拆分开，两者通过一个清晰的数据结构沟通。
    + 如果两个方向有更多的来回调用，就该创建适当的模块，然后`搬移函数`把处理逻辑分开。
    + 如果函数内部混合了两类处理逻辑就`提炼函数`将其分开；如果是类就`提炼类`
  8. 霰弹式修改 如果每遇到某种变化，都必须在许多不同的类内进行修改，那么就是注意了
    + `搬移函数`和`搬移字段`把所有需要修改的代码放入一个模块
    + 如果多个函数操作相同数据，使用`函数组合成类`
    + 如果多个函数是转化或者充实数据，使用`函数组合成变换`
    + 如果函数输出是为了计算结果的逻辑，使用`拆分阶段`
    霰弹式修改常用的策略是使用与内联相关的重构，`内联函数`或者`内联类` 把本不应该分选的逻辑集中
  9. feature envy
    所谓模块化，将代码分出区域，最大化内部交互、最小化跨域交互。如果一个函数跟另一个模块中的函数或者数据交流格外频繁，这就是典型的‘依恋情结’
    + `搬移函数` 将对应的函数与数据放到一起
    + 如果只有一小部分，那么先`提炼函数`，再`搬移函数`
    如果出现该功能与多个模块的函数或者数据交互，就把这个功能放到交互最平凡的模块中
    解决问题的原则是：尽可能的将数据和引用这些数据的行为放在一起，如果出现例外，我们就搬移那些行为，保持变化在一个位置发生（策略模式和访问者模式）
  10. 数据泥团
    将总是同时出现的数据，提炼成一个类，如果函数用到类中的数据可以直接传递对象，避免过长的函数多传参。判断的办法是，多个数据删除一个，其他的数据是不是就失去意义了，如果是这样那么就需要提炼一个类。创建一个类而不是一个记录的结构，这样后续可以将和数据相关的行为添加到类中。
  11. 基本类型偏执 ？
  12. 重复的switch语句 `以多态取代条件表达式`
  13. 循环语句：`管道取代循环` (filter、map) 注重的是清晰的结构和处理数据的动作
  14. 冗余的元素 ？
  15. 夸夸其谈的通用性

注：
  + 在开发阶段要考虑到实现一段简洁清晰的代码的成本
  + 重构与添加新功能切换不同的分支进行
  + YAGNI（you aren‘t going to need it）：
    只针对当前的需求实现高质量的软件设计，不过度预设不完备的功能。（补充完整）
  + 关于简单设计和架构思考：
    简单设计和架构思考是两种软件设计中不同的思维方式。编写一个函数时为了考虑通用或者复用性，会为函数添加参数。在某些场景之下会添加多个参数，这些参数是一种灵活机制。但是多个参数，会使函数本身变得复杂难以维护。在新增功能或维护这个函数的时候都具备很大的难度。另外，未来需求的变更往往并非如我们所设计的那样。因此有时候灵活机制反而变得不灵活。在很多场景下我们只需要根据当前的需求完成高质量的设计，随着对用户需求的加深，对原有设计进行重构即可。如果一个参数不能做到不同调用者传入不同的参数值，那么这个参数就不应该被添加。在设计一个软件时，如果考虑到之后的重构是困难的，那么可以添加必要的参数，提高软件的灵活性
  + 相关书籍：
    《重构手册》《重构与模式》《重构HTML》《修改代码的艺术》
