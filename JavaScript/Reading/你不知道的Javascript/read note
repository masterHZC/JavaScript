# 你不知道的JavaScript
## 作用域和闭包
### Question
  1. 变量储存在哪
  2. 程序如何找到变量
  3. 作用域的规则
  4. 编译器编译了什么？引擎在运行时的做了什么？
### 编译原理
 + 传统编译语言的编译流程
   1. 词法分析
    将字符串解析成有意义的代码块，被称为词法单元（Token）
> 分词与词法分析直接间的区别：词法分析一个过程，词法单元生成器在判断一个变量（a）的状态的过程
   2. 语法分析
    将Token流转换成“抽象语法树”
```
  Token: var, a, =, 2
    VariableDeclaration
Identifier: a     AssignmentExpression
                            NumericLiteral: 2
```
   3. 生成代码
    将AST转换成可执行的代码的过程就是 “代码生成”

 + JavaScript编译
   JavaScript不存在预编译，大部分情况是在执行前进行编译，编译结束后立即执行。但是编译的过程与传统的编译过程并无差别

### 作用域
  + 引擎：javascript的编译以及执行
  + 编译器：语法分析以及代码生成
  + 作用域：1. 收集和维护所有声明的变量 2. 查询所收集和维护的变量 3. 确认执行代码访问某一变量的权限

#### `var a = 2;` 的执行过程
  1. `var a`: 确认作用域内是否存在该变量，如果存在忽略本次声明继续编译。否则，会在当前作用域集合中声明一个新变量，命名为a
  2. 生成AST继而生成运行时代码。这些代码用来处理 `a = 2` 这个赋值过程
  3. 引擎在运行时阶段，现在该作用域集合中寻找叫做a的变量。如果存在，就是用该变量，如果不存在，会继续查找
  4. 找到为a的变量，赋值2，没找到抛出异常
> ReferenceError: a is not defined
`var a = 2` 这个表达式执行了两个动作，一个是编译器解析 `var a` 确认并执行变量的声明相关操作。第二个是在引擎运行时阶段为变量a赋值，如果找到该变量就执行赋值，否则抛出异常
#### LHS和RHS
  引擎会通过LHS的方式查变量。
> LHS：需要为赋值操作寻找目标变量，RHS：寻找目标变量的值
```js
 function foo(a) {
   // var a = 2 LHS
   console.log(a) // RHS*2 console|a
 }
 foo(2) // foo RHS
 // 有一个需要注意的问题，函数声明并不使用 LHS 查询，因为引擎在执行过程中并不会分出单独线程来将函数分配给foo，而是在函数声明和赋值同时进行了
```
一下的代码出现几次LHS和RHS
```js
  function foo(a) { 
    var b = a;
    return a + b; 
  }
  var c = foo( 2 );
  // LHS: c, a, b
  // RHS: foo, a, a, b
```
